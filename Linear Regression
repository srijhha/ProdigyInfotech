# Suppress warnings
import warnings
warnings.filterwarnings('ignore')

# Import necessary packages
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

# Load and preview the dataset
housing = pd.read_csv("../input/Housing.csv")
housing.head()

# Check for null values
housing.isnull().sum()

# Outlier treatment for 'price' and 'area'
for col in ['price', 'area']:
    Q1 = housing[col].quantile(0.25)
    Q3 = housing[col].quantile(0.75)
    IQR = Q3 - Q1
    housing = housing[(housing[col] >= Q1 - 1.5*IQR) & (housing[col] <= Q3 + 1.5*IQR)]

# Convert binary columns to 0/1
binary_cols = ['mainroad', 'guestroom', 'basement', 'hotwaterheating', 'airconditioning', 'prefarea']
housing[binary_cols] = housing[binary_cols].apply(lambda x: x.map({'yes': 1, 'no': 0}))

# Create dummy variables for 'furnishingstatus'
housing = pd.concat([housing, pd.get_dummies(housing['furnishingstatus'], drop_first=True)], axis=1)
housing.drop(['furnishingstatus'], axis=1, inplace=True)

# Split the data into train and test sets
from sklearn.model_selection import train_test_split
np.random.seed(0)
df_train, df_test = train_test_split(housing, train_size=0.7, random_state=100)

# Scale numeric features
from sklearn.preprocessing import MinMaxScaler
scaler = MinMaxScaler()
num_vars = ['area', 'bedrooms', 'bathrooms', 'stories', 'parking', 'price']
df_train[num_vars] = scaler.fit_transform(df_train[num_vars])

# Correlation heatmap
plt.figure(figsize=(10, 6))
sns.heatmap(df_train.corr(), annot=True, cmap="YlGnBu")
plt.show()

# Split data into X and y for model building
y_train = df_train.pop('price')
X_train = df_train

# Feature selection using RFE
from sklearn.linear_model import LinearRegression
from sklearn.feature_selection import RFE
lm = LinearRegression()
rfe = RFE(lm, n_features_to_select=6).fit(X_train, y_train)
selected_cols = X_train.columns[rfe.support_]

# Build model using statsmodels
import statsmodels.api as sm
X_train_rfe = sm.add_constant(X_train[selected_cols])
model = sm.OLS(y_train, X_train_rfe).fit()
print(model.summary())

# Calculate VIF
from statsmodels.stats.outliers_influence import variance_inflation_factor
vif = pd.DataFrame()
vif['Features'] = X_train_rfe.columns
vif['VIF'] = [variance_inflation_factor(X_train_rfe.values, i) for i in range(X_train_rfe.shape[1])]
print(vif.sort_values(by="VIF", ascending=False))

# Visualization of actual vs predicted values
y_train_pred = model.predict(X_train_rfe)

plt.figure(figsize=(10, 6))
plt.scatter(y_train, y_train_pred)
plt.plot([0, 1], [0, 1], '--r')
plt.xlabel("Actual Price")
plt.ylabel("Predicted Price")
plt.title("Actual vs Predicted Price (Training set)")
plt.show()

# Residual plot
residuals = y_train - y_train_pred

plt.figure(figsize=(10, 6))
sns.distplot(residuals, bins=20)
plt.xlabel("Residuals")
plt.ylabel("Frequency")
plt.title("Residuals Distribution")
plt.show()

# Predict on the test set
df_test[num_vars] = scaler.transform(df_test[num_vars])
y_test = df_test.pop('price')
X_test = df_test[selected_cols]
X_test_rfe = sm.add_constant(X_test)
y_test_pred = model.predict(X_test_rfe)

# Visualization of actual vs predicted values for the test set
plt.figure(figsize=(10, 6))
plt.scatter(y_test, y_test_pred)
plt.plot([0, 1], [0, 1], '--r')
plt.xlabel("Actual Price")
plt.ylabel("Predicted Price")
plt.title("Actual vs Predicted Price (Test set)")
plt.show()
